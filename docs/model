

<==========================================> DAL (Data Access Layer) <==========================================>

    Defined Data classes

<==========================================> ADL (Abstraction Data Layer) <==========================================>

    PHP::PDO (http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/)

        - CONNECTION AND ERRORS
                 # connect to the database
                try {
                  $DBH = new PDO("mysql:host=$host;dbname=$dbname", $user, $pass);
                  $DBH->setAttribute( PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION );

                  # UH-OH! Typed DELECT instead of SELECT!
                  $DBH->prepare('DELECT name FROM people');
                }
                catch(PDOException $e) {
                        echo "I'm sorry, Dave. I'm afraid I can't do that.";
                        file_put_contents('PDOErrors.txt', $e->getMessage(), FILE_APPEND);
                }


        - INPUT DATA
                # STH means "Statement Handle"
                $STH = $DBH->prepare("INSERT INTO folks ( first_name ) values ( 'Cathy' )");
                $STH->execute();


        - PLACEHOLDERS (Avoid SQL injection)
                # unnamed placeholders
                $STH = $DBH->("INSERT INTO folks (name, addr, city) values (?, ?, ?);

                # named placeholders
                $STH = $DBH->("INSERT INTO folks (name, addr, city) value (:name, :addr, :city)");

                Unnamed Placeholders
                        # assign variables to each place holder, indexed 1-3  
                        $STH->bindParam(1, $name);  
                        $STH->bindParam(2, $addr);  
                        $STH->bindParam(3, $city);  

                        # insert one row  
                        $name = "Daniel"  
                        $addr = "1 Wicked Way";  
                        $city = "Arlington Heights";  
                        $STH->execute();  

                        # insert another row with different values  
                        $name = "Steve"  
                        $addr = "5 Circle Drive";  
                        $city = "Schaumburg";  
                        $STH->execute();
                    There are two steps here. First, we assign variables to the various placeholders (lines 2-4). Then, we assign values to those placeholders and execute the statement. To send another set of data, just change the values of those variables and execute the statement again.
                    Does this seem a bit unwieldy for statements with a lot of parameters? It is. However, if your data is stored in an array, there’s an easy shortcut:
                    view plaincopy to clipboardprint?
                        # the data we want to insert  
                        $data = array('Cathy', '9 Dark and Twisty Road', 'Cardiff');  

                        $STH = $DBH->("INSERT INTO folks (name, addr, city) values (?, ?, ?);  
                        $STH->execute($data);  
                    The data in the array applies to the placeholders in order. $data[0] goes into the first placeholder, $data[1] the second, etc. However, if your array indexes are not in order, this won’t work properly, and you’ll need to re-index the array.
                
                Named Placeholders
                    You could probably guess the syntax, but here’s an example:
                        # the first argument is the named placeholder name - notice named  
                        # placeholders always start with a colon.  
                        $STH->bindParam(':name', $name);  
                    You can use a shortcut here as well, but it works with associative arrays. Here’s an example:
                        # the data we want to insert  
                        $data = array( 'name' => 'Cathy', 'addr' => '9 Dark and Twisty', 'city' => 'Cardiff' );  

                        # the shortcut!  
                        $STH = $DBH->("INSERT INTO folks (name, addr, city) value (:name, :addr, :city)");  
                        $STH->execute($data); 
                    The keys of your array do not need to start with a colon, but otherwise need to match the named placeholders. If you have an array of arrays you can iterate over them, and simply call the execute with each array of data.
                    Another nice feature of named placeholders is the ability to insert objects directly into your database, assuming the properties match the named fields. Here’s an example object, and how you’d perform your insert:
                        # a simple object  
                        class person {  
                            public $name;  
                            public $addr;  
                            public $city;  

                            function __construct($n,$a,$c) {  
                                $this->name = $n;  
                                $this->addr = $a;  
                                $this->city = $c;  
                            }  
                            # etc ...  
                        }  

                        $cathy = new person('Cathy','9 Dark and Twisty','Cardiff');  

                        # here's the fun part:  
                        $STH = $DBH->("INSERT INTO folks (name, addr, city) value (:name, :addr, :city)");  
                        $STH->execute((array)$cathy);  
                    By casting the object to an array in the execute, the properties are treated as array keys.


        - SELECT DATA
            Data is obtained via the ->fetch(), a method of your statement handle. Before calling fetch, it’s best to tell PDO how you’d like the data to be fetched. You have the following options:
                PDO::FETCH_ASSOC: returns an array indexed by column name
                PDO::FETCH_BOTH (default): returns an array indexed by both column name and number
                PDO::FETCH_BOUND: Assigns the values of your columns to the variables set with the ->bindColumn() method
                PDO::FETCH_CLASS: Assigns the values of your columns to properties of the named class. It will create the properties if matching properties do not exist
                PDO::FETCH_INTO: Updates an existing instance of the named class
                PDO::FETCH_LAZY: Combines PDO::FETCH_BOTH/PDO::FETCH_OBJ, creating the object variable names as they are used
                PDO::FETCH_NUM: returns an array indexed by column number
                PDO::FETCH_OBJ: returns an anonymous object with property names that correspond to the column names
            In reality, there are three which will cover most situations: FETCH_ASSOC, FETCH_CLASS, and FETCH_OBJ. In order to set the fetch method, the following syntax is used:
                $STH->setFetchMode(PDO::FETCH_ASSOC);  
            You can also set the fetch type directly within the ->fetch() method call.

            - FETCH_ASSOC
                This fetch type creates an associative array, indexed by column name. This should be quite familiar to anyone who has used the mysql/mysqli extensions. Here’s an example of selecting data with this method:
                    # using the shortcut ->query() method here since there are no variable  
                    # values in the select statement.  
                    $STH = $DBH->query('SELECT name, addr, city from folks');  

                    # setting the fetch mode  
                    $STH->setFetchMode(PDO::FETCH_ASSOC);  

                    while($row = $STH->fetch()) {  
                        echo $row['name'] . "\n";  
                        echo $row['addr'] . "\n";  
                        echo $row['city'] . "\n";  
                    }
                The while loop will continue to go through the result set one row at a time until complete.

            - FETCH_OBJ
                This fetch type creates an object of std class for each row of fetched data. Here’s an example:
                    # creating the statement  
                    $STH = $DBH->query('SELECT name, addr, city from folks');  

                    # setting the fetch mode  
                    $STH->setFetchMode(PDO::FETCH_OBJ);  

                    # showing the results  
                    while($row = $STH->fetch()) {  
                        echo $row->name . "\n";  
                        echo $row->addr . "\n";  
                        echo $row->city . "\n";  
                    }
            - FETCH_CLASS
                The properties of your object are set BEFORE the constructor is called. This is important.
                This fetch method allows you to fetch data directly into a class of your choosing. When you use FETCH_CLASS, the properties of your object are set BEFORE the constructor is called. Read that again, it’s important. If properties matching the column names don’t exist, those properties will be created (as public) for you.
                This means if your data needs any transformation after it comes out of the database, it can be done automatically by your object as each object is created.
                As an example, imagine a situation where the address needs to be partially obscured for each record. We could do this by operating on that property in the constructor. Here’s an example:
                    class secret_person {  
                        public $name;  
                        public $addr;  
                        public $city;  
                        public $other_data;  

                        function __construct($other = '') {  
                            $this->address = preg_replace('/[a-z]/', 'x', $this->address);  
                            $this->other_data = $other;  
                        }  
                    }  
                As data is fetched into this class, the address has all its lowercase a-z letters replaced by the letter x. Now, using the class and having that data transform occur is completely transparent:
                    $STH = $DBH->query('SELECT name, addr, city from folks');  
                    $STH->setFetchMode(PDO::FETCH_CLASS, 'secret_person');  

                    while($obj = $STH->fetch()) {  
                        echo $obj->addr;  
                    }  
                If the address was ’5 Rosebud,’ you’d see ’5 Rxxxxxx’ as your output. Of course, there may be situations where you want the constructor called before the data is assigned. PDO has you covered for this, too.
                    $STH->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, 'secret_person');  
                Now, when you repeat the previous example with this fetch mode (PDO::FETCH_PROPS_LATE) the address will NOT be obscured, since the constructor was called and the properties were assigned.
                Finally, if you really need to, you can pass arguments to the constructor when fetching data into objects with PDO:
                    $STH->setFetchMode(PDO::FETCH_CLASS, 'secret_person', array('stuff'));  
                If you need to pass different data to the constructor for each object, you can set the fetch mode inside the fetch method:
                    $i = 0;  
                    while($rowObj =  $STH->fetch(PDO::FETCH_CLASS, 'secret_person', array($i))) {  
                        // do stuff  
                        $i++  
                    }


            - UTILS
                While this isn’t meant to cover everything in PDO (it’s a huge extension!) there are a few more methods you’ll want to know in order to do basic things with PDO.
                    $DBH->lastInsertId();  
                The ->lastInsertId() method is always called on the database handle, not statement handle, and will return the auto incremented id of the last inserted row by that connection.
                    $DBH->exec('DELETE FROM folks WHERE 1');  
                    $DBH->exec("SET time_zone = '-8:00'");  
                The ->exec() method is used for operations that can not return data other then the affected rows. The above are two examples of using the exec method.
                    $safe = $DBH->quote($unsafe);  
                The ->quote() method quotes strings so they are safe to use in queries. This is your fallback if you’re not using prepared statements.
                    $rows_affected = $STH->rowCount();  
                The ->rowCount() method returns an integer indicating the number of rows affected by an operation. In at least one known version of PDO, according to [this bug report](http://bugs.php.net/40822) the method does not work with select statements. If you’re having this problem, and can’t upgrade PHP, you could get the number of rows with the following:
                    $sql = "SELECT COUNT(*) FROM folks";  
                    if ($STH = $DBH->query($sql)) {  
                        # check the row count  
                        if ($STH->fetchColumn() > 0) {  

                        # issue a real select here, because there's data!  
                        }  
                        else {  
                            echo "No rows matched the query.";  
                        }  
                    }

    PDO::PDO_MYSQL||PDO_SQLITE||PDO::POSTGRESQL||...

<==========================================> Database <==========================================>

    MySQL||SQLite||PostgreSQL||...